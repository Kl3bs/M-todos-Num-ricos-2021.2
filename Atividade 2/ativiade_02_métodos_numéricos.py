# -*- coding: utf-8 -*-
"""Ativiade 02 - Métodos Numéricos.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18eXGphO3K2Gk0uH7LlTxoaZK_siMEooW
"""

import numpy as np
import math
import time 
from math import sqrt
import matplotlib.pyplot as plt

"""**QUESTÃO 1**

Equações :
"""

def gaussElimination(a,b):
    n = len(b)
     
    for k in range(0,n-1):
        for i in range(k+1,n):
            if a[i,k] != 0.0:
                lam = a [i,k]/a[k,k]
                a[i,k+1:n] = a[i,k+1:n] - lam*a[k,k+1:n]
                b[i] = b[i] - lam*b[k]
    for k in range(n-1,-1,-1):
        b[k] = (b[k] - np.dot(a[k,k+1:n],b[k+1:n]))/a[k,k]
    
    return b

def plu(A):
  
    L = np.zeros_like(A, dtype=float)
    U = np.zeros_like(A, dtype=float)
    N = np.size(A, 0)

    for k in range(N):
        L[k, k] = 1
        U[k, k] = A[k, k] - np.dot(L[k, :k], U[:k, k]) 
        for j in range(k+1, N):
            U[k, j] = A[k, j] - np.dot(L[k, :k], U[:k, j])
        for i in range(k+1, N):
            L[i, k] = (A[i, k] - np.dot(L[i, :k], U[:k, k])) / U[k, k]

    return L, U


def LUsolver(A, b):
    
    m = len(A) 
    L, U = plu(A) 
    x = np.zeros(b.size)  
    y = np.zeros(b.size) 
 
    for i in range(0, m, 1):
        y[i] = b[i] / L[i][i]
        for j in range(0, i, 1):
            y[i] -= y[j] * L[i][j]
     
    for i in range(m-1, -1, -1):
        x[i] = y[i] / U[i][i]
        for j in range(i-1, -1, -1):
            U[i] -= x[i] * U[i][j]
    return x

def cholesky(A,B):
    start_time = time.time()
    n = len(A)
    # Create zero matrix for L
    L = np.zeros(np.shape(A))
    # Perform the Cholesky decomposition
    for i in range(n):
        for k in range(i+1):
            tmp_sum = sum(L[i][j] * L[k][j] for j in range(k)) #this is the sum that appears in both formulas
            
            if i == k: # Diagonal elements
                L[i][k] = np.sqrt(A[i][i] - tmp_sum)
            else:
                # Off diagonal elements
                L[i][k] = (1.0 / L[k][k] * (A[i][k] - tmp_sum))    
    choleskySol(L, np.transpose(L), B)
    return time.time() - start_time
    

def choleskySol(L,U,b):
  L=np.array(L, float)
  U=np.array(U, float)
  b=np.array(b, float)

  n,_=np.shape(L)
  y=np.zeros(n)
  x=np.zeros(n)

# Forward substitution
  for i in range(n):
    sumj=0
    for j in range(i):
      sumj += L[i,j]*y[j]
    y[i]=(b[i]-sumj)/L[i,i]

# Backward substitution  
  for i in range(n-1, -1, -1):
    sumj=0
    for j in range(i+1,n):
      sumj += U[i,j] * x[j]
    x[i]=(y[i]-sumj)/U[i,i]
  return x

#EQUAÇÃO 1
a1=np.array([[1.0,1.0,2.0],[2.0,-1.0,-1.0],[1.0,-1.0,-1.0]])
b1=np.array([4.0,0.0,-1.0])

#EQUAÇÃO 2

a2=np.array([[1.0,2.0,-1.0],[2.0,2.0,-2.0],[1.0,-2.0,1.0]])
b2=np.array([2.0,3.0,0.0])

#EQUAÇÃO 3

a3  = np.array([[1.0,1.0,0.0], [1.0, 2.0, -1.0],[0.0, -1.0, 3.0]])
b3 = np.array([1.0, 1.0, 2.0])


print("[Gauss elimination] - System of equations 1, x =",gaussElimination(a1,b1))
print("[Gauss elimination] - System of equations 2, x =",gaussElimination(a2,b2))
print("[Gauss elimination] - System of equations 3, x =",gaussElimination(a3,b3))

print('\n')

print("[PLU Decomposition] - System of equations 1\n",plu(a1)[1])
print("[PLU Decomposition] - System of equations 2\n",plu(a2)[1])
print("[PLU Decomposition] - System of equations 3\n",plu(a3)[1])

print('\n')

l = cholesky(a1)
print(choleskySol(l, np.transpose(l), b1))

l = cholesky(a2)
print(choleskySol(l, np.transpose(l), b2))

l = cholesky(a3)
print(choleskySol(l, np.transpose(l), b3))



# print(a1)
# print("x =",x)

# print(choleskySol(cholesky(a), b))

"""**QUESTÃO 2**"""

def gauss_jordan(A, b, table: list) -> np.array:
 
    n = len(b)
    A_aux = np.copy(A)
    b_aux = np.copy(b)

    for k in range(n):
        
        if np.fabs(A_aux[k, k]) < 1.0e-12:
            for i in range(k + 1, n):
                if np.fabs(A_aux[i, k]) > np.fabs(A_aux[k, k]):
                    A_aux[[k, i]] = A_aux[[i, k]]
                    b_aux[[k, i]] = b_aux[[i, k]]
                    table.append([k, 'Swap', i, None, None])
                    break

         
        pivot = A_aux[k, k]
        A_aux[k, k:] /= pivot
        b_aux[k] /= pivot

        
        for i in range(n):
            if i == k or A_aux[i, k] == 0:
                continue

            factor = A_aux[i, k]
            A_aux[i, k:] -= A_aux[k, k:] * factor
            b_aux[i] -= b_aux[k] * factor

            table.append([k, 'Elimination', i, pivot, factor])

    return b_aux

"""**QUESTÃO 3: Implemente o algoritmo abaixo para gerar, aleatoriamente, matrizes positivas definidas. Exiba 3 exemplos e explique porque qualquer matriz gerada
com este algoritmo ´e positiva definida.**"
"""

def generateRandomMatrix(n, int_only):
    #n is the matrix size
    #int_only = True returns an integer SPD matrix, False is the default value
    if int_only == True:
        return np.random.randint(10, size=(n, n)) 
    return np.random.rand(n, n)

def generateSPD(n,int_only:bool=False):
    A = generateRandomMatrix(n, int_only)
    A_transpose = np.transpose(A)
    return np.dot(A, A_transpose)    


print("Matrix 1:\n", generateSPD(2), "\n")
print("Matrix 2:\n", generateSPD(3, True), "\n")
print("Matrix 2:\n", generateSPD(15), "\n")

"""Todas as matrizes são positivas e definidas, pois são geradas a partir do produto de uma matriz A pela sua transposta (A = A ̇Aˆt).

**QUESTÃO 4**

A)
"""

def generateRandomVector(n):
    return np.random.rand(n)

x = [10,100,500,1000,1500,2000]
y = []

def getCholeskysTime(n):
  n = n
  time = 0
  for item in range(10):
    A = generateSPD(n)
    B =  generateRandomVector(n)
    time += cholesky(A,B)

  print("  Total time: %s" % time)

  y.append(time/60)
  return time

getCholeskysTime(10)
getCholeskysTime(100)
getCholeskysTime(500)
getCholeskysTime(1000)
getCholeskysTime(1500)
getCholeskysTime(2000)
 

 

plt.plot(x, y)
plt.show()